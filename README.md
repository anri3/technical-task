# 書籍管理システムのバックエンドAPI

書籍と著者を管理するAPIです。

## 🏠アーキテクチャ概要
本プロジェクトでは、レイヤードアーキテクチャを採用しています。 主にCRUD（作成・読み取り・更新・削除）操作を効率的に行うという要件に基づいて決定しました。

各レイヤーの役割は以下の通りです。

- Controller: APIエンドポイントごとに定義され、クライアントからのリクエストを受け付け、適切なサービスに処理を委譲します。
- DTO: クライアントとの間でやり取りされるリクエストおよびレスポンスのデータ構造を定義します。これにより、外部とのデータの受け渡しが明確になります。
- Service: アプリケーションのビジネスロジックを実装する中心的なレイヤーです。必要に応じて複数のRepositoryを連携させ、具体的な機能を提供します。
- Repository: データベースへのCRUD操作（データの永続化、取得、更新、削除）を担当します。Service層から呼び出され、データアクセスの詳細を隠蔽します。
- Entity: データベースのテーブル構造に直接対応するデータモデルを定義します。

## 🗄️データモデル
APIを介したデータ送受信のために以下の主要なDTO (Data Transfer Object) を使用しています。これらは、クライアントとサーバー間のデータ形式を明確にし、APIの利用を容易にするために定義されています。

1. BookRequest  
API共通の書籍内容を定義するリクエストボディとして使用されます。新しい書籍の作成や既存の書籍情報の更新時などに利用されます。
- title (文字列): 書籍のタイトル
- price (数値): 書籍の価格
- isPublished (真偽値): 書籍の出版状況  

2. AuthorRequest  
API共通の著者内容を定義するリクエストボディとして使用されます。新しい著者の登録や既存の著者情報の更新時などに利用されます。

- name (文字列): 著者の氏名
- birthday (日付): 著者の生年月日  

3. AuthorResponse  
著者の書籍参照APIのレスポンスボディとして使用されるDTOです。著者に紐づく書籍情報をクライアントに返却する際に利用されます。

- title (文字列): 書籍のタイトル
- price (数値): 書籍の価格
- isPublished (真偽値): 書籍の出版状況

## 📐 各APIの設計・ロジック
- 必要な機能  
書籍と著者の情報の登録・更新機能: データベースへのデータの永続化と更新を行います。  
著者に紐づく本の取得機能: 特定の著者に関連する書籍情報を検索・取得します。

- 前提  
登録: 書籍タイトルと著者情報が完全に一致する既存データが存在しない場合にのみ、新しい書籍と著者情報を登録できます。既存の一致データがある場合は登録を行いません。  
更新:フロントエンドから、変更がない情報を含めて、id に紐づく全ての情報が送られてくることを前提とします。 idに紐づく著者情報のみの更新も可能です。  
参照: 著者の名前を完全一致検索し、該当する著者とその関連書籍を一覧で返却します。

各APIの設計とビジネスロジック
1. 書籍情報登録API  
   - 目的: 新しい書籍と著者をデータベースに登録します。  
   - 主要なビジネスロジック:リクエストされた書籍タイトルと著者情報がデータベース上の既存データと完全に一致する場合は、重複とみなし登録を行いません。
   上記以外の場合は、新しい書籍と著者の情報を登録します。  
   - 依存関係: BooksRepository を使用します。  
   - 例外処理:書籍タイトルと著者情報が一致する既存データが存在する場合は、HTTP 400 Bad Request を返却します。
   その他の予期せぬエラーが発生した場合は、HTTP 500 Internal Server Error を返却します。
2. 書籍情報更新API  
    - 目的: 既存の書籍と著者情報を更新します。  
   - 主要なビジネスロジック:リクエストのidに紐づく書籍と著者情報を更新します。 リクエストに含まれる著者情報にidがあれば、そのidに紐づく著者情報を更新します。 リクエストに id がない著者が含まれている場合は、新しい著者として登録します。 データベースに既存で登録されている著者が、今回のリクエストには含まれていない場合、その著者の情報を削除します。  
   - 依存関係: BooksRepository、AuthorsRepository、BooksAuthorsRepository を使用します。  
   - 例外処理:リクエストで指定された書籍IDがデータベースに登録されていない場合、またはリクエストで指定された著者IDが存在しない場合は、HTTP 400 Bad Request を返却します。
   その他の予期せぬエラーが発生した場合は、HTTP 500 Internal Server Error を返却します。
3. 著者更新API  
    - 目的: 著者の情報を更新します。  
   - 主要なビジネスロジック:リクエストのidに紐づく著者情報を更新します。  
   指定された id が存在しない場合は、新しい著者として登録は行いません（更新のみを目的とするため）。  
   - 依存関係: AuthorsRepository を使用します。  
   - 例外処理:リクエストで指定されたIDがデータベースに登録されていない場合は、HTTP 400 Bad Request を返却します。
   その他の予期せぬエラーが発生した場合は、HTTP 500 Internal Server Error を返却します。
4. 著者の書籍参照API  
    - 目的: 著者名に基づいて、関連する書籍の一覧を取得します。  
   - 主要なビジネスロジック:提供された著者名と完全に一致する著者を検索し、その著者に紐づく書籍の一覧を取得します。  
   - 依存関係: BooksRepository、AuthorsRepository を使用します。  
   - 例外処理:検索された著者名に該当する著者が存在しない場合は、HTTP 400 Bad Request を返却します。 その他の予期せぬエラーが発生した場合は、HTTP 500 Internal Server Error を返却します。

## 🧪 単体テストの目的とアプローチ
各コンポーネントのビジネスロジックが独立して正しく機能することを検証することを主な目的としています。これにより、問題発生時の原因特定を容易にし、コードの品質と信頼性を高めます。

各レイヤーにおける単体テストのアプローチ  
1. Repository  
Repository層のテストでは、実際にデータベースに接続し、test-data.sql ファイルに定義されたテストデータを使用して検証を行います。
このアプローチを採用することで、以下の点を確実にします。

- 実際のデータベース操作の検証: INSERT、SELECT、UPDATE、DELETE といったCRUD操作が、意図した通りにデータベースに対して実行されるかを確認します。
- SQLクエリの正確性: 生成されるSQLクエリが正しく、データベーススキーマと整合性があることを検証します。
- データ永続化の確認: データの保存、取得、更新、削除が正しく行われ、永続化層の信頼性を保証します。

2. Service  
Service層のテストでは、モック（Mock） を積極的に使用します。具体的には、Serviceクラスが依存するRepositoryをモック化します。
この方針により、以下の利点が得られます。

- ビジネスロジックの独立した検証: Serviceクラス自身のビジネスロジックに焦点を当て、その複雑な処理フローや条件分岐が正しく動作するかを独立して検証できます。
- テストの高速化: 実際のデータベース接続や外部サービスへのアクセスを排除することで、テスト実行時間を大幅に短縮します。
- テストの安定性: 外部要因（ネットワーク遅延、データベースの状態など）に左右されず、常に安定したテスト結果を得られます。

3. DTO (Data Transfer Object)  
DTOのテストでは、主にそのバリデーションチェックが正しく行われるかを確認します。

- 入力値の整合性検証: APIからのリクエストやレスポンスの際に、DTOに定義されたバリデーションルール（例: 必須項目、文字列長、数値の範囲、正規表現など）が正しく適用され、不正なデータが拒否されることを検証します。
- エラーハンドリングの確認: 不正なデータが入力された場合に、期待通りのエラーメッセージやステータスが返却されることを確認し、APIの堅牢性を保証します。

## 🛠 使用技術スタック

- Kotlin
- Spring Boot
- JOOQ
- Flyway
- PostgreSQL (Docker)
- Gradle

## 📦 セットアップ手順とビルド

1. **PostgreSQLコンテナ起動**
docker-compose up -d

2. **Flywayでマイグレーション実行**
./gradlew flywayMigrate

3. **JOOQコード自動生成**
./gradlew generateJooq

4. **アプリ起動**
./gradlew bootRun

## 📡APIリクエスト
- ローカル環境での正常リクエストの例のみ記述します　　

1. 書籍情報登録API  
- POST
- http://localhost:8080/book/info  　
- Content-Type：application/json　
- リクエストボディ例：
`
   {
   "title": "テスト本",
   "price": 4000,
   "isPublished": false,
   "authors": [
   {
   "name": "テスト1",
   "birthday": "1999-05-20"
   },
   {
   "name": "テスト2",
   "birthday": "1990-01-01"
   }
   ]
   }
`

2. 書籍情報更新API
- POST
- http://localhost:8080/book/info/{更新する書籍id}  　
- Content-Type：application/json　
- リクエストボディ例：
`
{
  "title": "テスト更新",
  "price": 5000,
  "isPublished": true,
  "authors": [
    {
      "authorId": "43",
      "name": "テスト43",
      "birthday": "1997-05-20"
    },
    {
      "authorId": "44",
      "name": "テスト44",
      "birthday": "1999-05-20"
    }
  ]
}
`

3. 著者更新API
- POST
- http://localhost:8080/book/author/{更新する著者id}  　
- Content-Type：application/json　
- リクエストボディ例：
`
{  
  "name": "テスト",
  "birthday": "1999-07-20"
}
`

4. 著者の書籍参照API
- POST
- http://localhost:8080/book/author/info  　
- Content-Type：application/json　
- リクエストボディ例：
`
{  
  "name": "テスト"
}
`